# coding: utf-8

"""
    Cerebral API

    The Wdata Preparation API allow users to import data sets from their source system, tag, organize, manipulate, share, export, and query against the data  # noqa: E501

    OpenAPI spec version: 1.0
    Contact: scoutteam@workiva.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class AdministrativeTasksApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def delete_workspace_using_delete(self, **kwargs):  # noqa: E501
        """Delete a single workspace  # noqa: E501

        Deletes all information in the workspace of the request. <b>This is a final operation and can't be undone</b>. Any state left in the workspace due to an error is in an indeterminate state and shouldn't be trusted. Some non-private information may be kept for auditing and metric purposes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_workspace_using_delete(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: BaseResponseOfstring
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_workspace_using_delete_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.delete_workspace_using_delete_with_http_info(**kwargs)  # noqa: E501
            return data

    def delete_workspace_using_delete_with_http_info(self, **kwargs):  # noqa: E501
        """Delete a single workspace  # noqa: E501

        Deletes all information in the workspace of the request. <b>This is a final operation and can't be undone</b>. Any state left in the workspace due to an error is in an indeterminate state and shouldn't be trusted. Some non-private information may be kept for auditing and metric purposes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_workspace_using_delete_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: BaseResponseOfstring
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_workspace_using_delete" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/admin/account', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BaseResponseOfstring',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def export_workspace_using_get(self, **kwargs):  # noqa: E501
        """Export a single workspace  # noqa: E501

        Returns a file that represents the entirety of the workspace of the request. You can upload this file into another workspace to replicate this one.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.export_workspace_using_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: BaseResponseOfTokenDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.export_workspace_using_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.export_workspace_using_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def export_workspace_using_get_with_http_info(self, **kwargs):  # noqa: E501
        """Export a single workspace  # noqa: E501

        Returns a file that represents the entirety of the workspace of the request. You can upload this file into another workspace to replicate this one.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.export_workspace_using_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: BaseResponseOfTokenDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method export_workspace_using_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/admin/export', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BaseResponseOfTokenDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def find_workspace_files_by_size_using_get(self, **kwargs):  # noqa: E501
        """Retrieve workspace files by size  # noqa: E501

        Returns a paged collection of the file meta associated with the workspace of the request, ordered by size.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.find_workspace_files_by_size_using_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int limit: The number of file meta objects to return, from 1 to 1000; by default, 1000
        :param str cursor: A paging cursor; if included, `limit` is ignored
        :param int offset: The item to start with on the page, greater than or equal to 0; by default, 0
        :return: PagedResponseOfFileMetaDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.find_workspace_files_by_size_using_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.find_workspace_files_by_size_using_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def find_workspace_files_by_size_using_get_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve workspace files by size  # noqa: E501

        Returns a paged collection of the file meta associated with the workspace of the request, ordered by size.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.find_workspace_files_by_size_using_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int limit: The number of file meta objects to return, from 1 to 1000; by default, 1000
        :param str cursor: A paging cursor; if included, `limit` is ignored
        :param int offset: The item to start with on the page, greater than or equal to 0; by default, 0
        :return: PagedResponseOfFileMetaDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['limit', 'cursor', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method find_workspace_files_by_size_using_get" % key
                )
            params[key] = val
        del params['kwargs']

        if self.api_client.client_side_validation and ('limit' in params and params['limit'] > 1000):  # noqa: E501
            raise ValueError("Invalid value for parameter `limit` when calling `find_workspace_files_by_size_using_get`, must be a value less than or equal to `1000`")  # noqa: E501
        if self.api_client.client_side_validation and ('limit' in params and params['limit'] < 1):  # noqa: E501
            raise ValueError("Invalid value for parameter `limit` when calling `find_workspace_files_by_size_using_get`, must be a value greater than or equal to `1`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/admin/usage/filesBySize', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagedResponseOfFileMetaDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_workspace_query_usage_using_get(self, **kwargs):  # noqa: E501
        """Retrieve workspace query usage  # noqa: E501

        Returns a Long that represents the number of bytes queried by the workspace of the request since the start time provided.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_workspace_query_usage_using_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str start_date: The earliest date of usage to consider
        :param str stop_date: The end date of usage to consider
        :return: BaseResponseOflong
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_workspace_query_usage_using_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_workspace_query_usage_using_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_workspace_query_usage_using_get_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve workspace query usage  # noqa: E501

        Returns a Long that represents the number of bytes queried by the workspace of the request since the start time provided.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_workspace_query_usage_using_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str start_date: The earliest date of usage to consider
        :param str stop_date: The end date of usage to consider
        :return: BaseResponseOflong
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['start_date', 'stop_date']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_workspace_query_usage_using_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'start_date' in params:
            query_params.append(('startDate', params['start_date']))  # noqa: E501
        if 'stop_date' in params:
            query_params.append(('stopDate', params['stop_date']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/admin/usage/query', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BaseResponseOflong',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_workspace_upload_usage_using_get(self, **kwargs):  # noqa: E501
        """Retrieve workspace upload usage  # noqa: E501

        Returns a Long that represents the number of bytes uploaded by the workspace associated with this request from the start time provided to now.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_workspace_upload_usage_using_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str start_date: The starting point to begin considering usage
        :param str stop_date: The ending point when considering usage
        :return: BaseResponseOflong
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_workspace_upload_usage_using_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_workspace_upload_usage_using_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_workspace_upload_usage_using_get_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve workspace upload usage  # noqa: E501

        Returns a Long that represents the number of bytes uploaded by the workspace associated with this request from the start time provided to now.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_workspace_upload_usage_using_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str start_date: The starting point to begin considering usage
        :param str stop_date: The ending point when considering usage
        :return: BaseResponseOflong
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['start_date', 'stop_date']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_workspace_upload_usage_using_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'start_date' in params:
            query_params.append(('startDate', params['start_date']))  # noqa: E501
        if 'stop_date' in params:
            query_params.append(('stopDate', params['stop_date']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/admin/usage/upload', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BaseResponseOflong',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def import_data_using_post(self, **kwargs):  # noqa: E501
        """Import data  # noqa: E501

        By default, deletes all information in the workspace of the request. <b>This is a final operation and can't be undone.</b>  Any state left in the workspace due to an error is in an indeterminate state and shouldn't be trusted. Some non-private information may be kept for auditing and metric purposes. After the delete, it then imports the tables, tags, and queries in the provided cb file into the workspace. <br><br>This is an asynchronous operation. Returns a 201 when the file is correctly decoded and its tables, queries, and tags are saved. Files continue to import after this call completes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_data_using_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file file: The file containing workspace information to import
        :param bool wipe: wipe
        :return: BaseResponseOfstring
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.import_data_using_post_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.import_data_using_post_with_http_info(**kwargs)  # noqa: E501
            return data

    def import_data_using_post_with_http_info(self, **kwargs):  # noqa: E501
        """Import data  # noqa: E501

        By default, deletes all information in the workspace of the request. <b>This is a final operation and can't be undone.</b>  Any state left in the workspace due to an error is in an indeterminate state and shouldn't be trusted. Some non-private information may be kept for auditing and metric purposes. After the delete, it then imports the tables, tags, and queries in the provided cb file into the workspace. <br><br>This is an asynchronous operation. Returns a 201 when the file is correctly decoded and its tables, queries, and tags are saved. Files continue to import after this call completes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_data_using_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file file: The file containing workspace information to import
        :param bool wipe: wipe
        :return: BaseResponseOfstring
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file', 'wipe']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method import_data_using_post" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'wipe' in params:
            query_params.append(('wipe', params['wipe']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/admin/import', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BaseResponseOfstring',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def validate_files_using_post(self, **kwargs):  # noqa: E501
        """Validate files  # noqa: E501

        Validates files associated with the provided table ID. Validation repairs any files in an inconsistent state, and deletes those without enough state to recover. All files deleted or repaired are returned.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.validate_files_using_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param StartValidateFilesDto validate_files_dto: The representation of the file to validate
        :return: BaseResponseOfValidateFilesDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.validate_files_using_post_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.validate_files_using_post_with_http_info(**kwargs)  # noqa: E501
            return data

    def validate_files_using_post_with_http_info(self, **kwargs):  # noqa: E501
        """Validate files  # noqa: E501

        Validates files associated with the provided table ID. Validation repairs any files in an inconsistent state, and deletes those without enough state to recover. All files deleted or repaired are returned.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.validate_files_using_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param StartValidateFilesDto validate_files_dto: The representation of the file to validate
        :return: BaseResponseOfValidateFilesDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['validate_files_dto']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method validate_files_using_post" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'validate_files_dto' in params:
            body_params = params['validate_files_dto']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/admin/validation/files', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BaseResponseOfValidateFilesDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def validate_tables_using_post(self, **kwargs):  # noqa: E501
        """Validate tables  # noqa: E501

        Validates the tables in the workspace associated with the request. Validation returns an entity that indicates the tables deleted due to bad state, and those with enough state and repaired.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.validate_tables_using_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: BaseResponseOfValidateTablesDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.validate_tables_using_post_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.validate_tables_using_post_with_http_info(**kwargs)  # noqa: E501
            return data

    def validate_tables_using_post_with_http_info(self, **kwargs):  # noqa: E501
        """Validate tables  # noqa: E501

        Validates the tables in the workspace associated with the request. Validation returns an entity that indicates the tables deleted due to bad state, and those with enough state and repaired.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.validate_tables_using_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: BaseResponseOfValidateTablesDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method validate_tables_using_post" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/admin/validation/tables', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BaseResponseOfValidateTablesDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
