# coding: utf-8

"""
    Cerebral API

    The Wdata Preparation API allow users to import data sets from their source system, tag, organize, manipulate, share, export, and query against the data  # noqa: E501

    OpenAPI spec version: 1.0
    Contact: scoutteam@workiva.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class QueryManagementApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def cancel_query_using_delete(self, query_result_id, **kwargs):  # noqa: E501
        """Cancel a running query  # noqa: E501

        Cancels a running query based on the provided result ID, and returns a cancelled result unless the query's already in a COMPLETED state.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cancel_query_using_delete(query_result_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str query_result_id: The unique identifier of the query result (required)
        :return: BaseResponseOfQueryResultDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cancel_query_using_delete_with_http_info(query_result_id, **kwargs)  # noqa: E501
        else:
            (data) = self.cancel_query_using_delete_with_http_info(query_result_id, **kwargs)  # noqa: E501
            return data

    def cancel_query_using_delete_with_http_info(self, query_result_id, **kwargs):  # noqa: E501
        """Cancel a running query  # noqa: E501

        Cancels a running query based on the provided result ID, and returns a cancelled result unless the query's already in a COMPLETED state.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cancel_query_using_delete_with_http_info(query_result_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str query_result_id: The unique identifier of the query result (required)
        :return: BaseResponseOfQueryResultDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['query_result_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cancel_query_using_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'query_result_id' is set
        if self.api_client.client_side_validation and ('query_result_id' not in params or
                                                       params['query_result_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `query_result_id` when calling `cancel_query_using_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'query_result_id' in params:
            path_params['queryResultId'] = params['query_result_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/queryresult/{queryResultId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BaseResponseOfQueryResultDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_query_using_post(self, **kwargs):  # noqa: E501
        """Create a new query  # noqa: E501

        Creates a query object and validates full permissions to ensure the requestor has access to all data sources being queried. This endpoint _doesn't_ execute the query; to execute, call the POST /queryresult method.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_query_using_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param QueryDto query_dto: The representation of the query to create
        :return: BaseResponseOfQueryDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_query_using_post_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_query_using_post_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_query_using_post_with_http_info(self, **kwargs):  # noqa: E501
        """Create a new query  # noqa: E501

        Creates a query object and validates full permissions to ensure the requestor has access to all data sources being queried. This endpoint _doesn't_ execute the query; to execute, call the POST /queryresult method.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_query_using_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param QueryDto query_dto: The representation of the query to create
        :return: BaseResponseOfQueryDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['query_dto']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_query_using_post" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'query_dto' in params:
            body_params = params['query_dto']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/query', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BaseResponseOfQueryDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_query_using_delete(self, query_id, **kwargs):  # noqa: E501
        """Delete a single query  # noqa: E501

        Deletes the query that matches the provided ID. If no such query is found, this is a no-op.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_query_using_delete(query_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str query_id: The unique identifier of the query (required)
        :return: BaseResponseOfstring
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_query_using_delete_with_http_info(query_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_query_using_delete_with_http_info(query_id, **kwargs)  # noqa: E501
            return data

    def delete_query_using_delete_with_http_info(self, query_id, **kwargs):  # noqa: E501
        """Delete a single query  # noqa: E501

        Deletes the query that matches the provided ID. If no such query is found, this is a no-op.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_query_using_delete_with_http_info(query_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str query_id: The unique identifier of the query (required)
        :return: BaseResponseOfstring
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['query_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_query_using_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'query_id' is set
        if self.api_client.client_side_validation and ('query_id' not in params or
                                                       params['query_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `query_id` when calling `delete_query_using_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'query_id' in params:
            path_params['queryId'] = params['query_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/query/{queryId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BaseResponseOfstring',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def download_query_result_using_get(self, query_result_id, **kwargs):  # noqa: E501
        """Download a query result  # noqa: E501

        Uses the Token Management API to create a token with the query result ID, which it then uses to download a CSV file of the query results.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.download_query_result_using_get(query_result_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str query_result_id: The unique identifier of the query result (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.download_query_result_using_get_with_http_info(query_result_id, **kwargs)  # noqa: E501
        else:
            (data) = self.download_query_result_using_get_with_http_info(query_result_id, **kwargs)  # noqa: E501
            return data

    def download_query_result_using_get_with_http_info(self, query_result_id, **kwargs):  # noqa: E501
        """Download a query result  # noqa: E501

        Uses the Token Management API to create a token with the query result ID, which it then uses to download a CSV file of the query results.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.download_query_result_using_get_with_http_info(query_result_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str query_result_id: The unique identifier of the query result (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['query_result_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method download_query_result_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'query_result_id' is set
        if self.api_client.client_side_validation and ('query_result_id' not in params or
                                                       params['query_result_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `query_result_id` when calling `download_query_result_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'query_result_id' in params:
            path_params['queryResultId'] = params['query_result_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/queryresult/{queryResultId}/download', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def export_query_result_to_spreadsheets_using_post(self, query_result_id, **kwargs):  # noqa: E501
        """Export query result to spreadsheets  # noqa: E501

        Exports a query result with the provided ID to Spreadsheets. To determine where to export the results, the request body should include a URL copied and pasted from the Spreadsheets UI. Returns a 404 if no matching query result is found.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.export_query_result_to_spreadsheets_using_post(query_result_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str query_result_id: The unique identifier of the query result (required)
        :param ExportQueryResultDto dto: The representation of the export query result
        :return: BaseResponseOfstring
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.export_query_result_to_spreadsheets_using_post_with_http_info(query_result_id, **kwargs)  # noqa: E501
        else:
            (data) = self.export_query_result_to_spreadsheets_using_post_with_http_info(query_result_id, **kwargs)  # noqa: E501
            return data

    def export_query_result_to_spreadsheets_using_post_with_http_info(self, query_result_id, **kwargs):  # noqa: E501
        """Export query result to spreadsheets  # noqa: E501

        Exports a query result with the provided ID to Spreadsheets. To determine where to export the results, the request body should include a URL copied and pasted from the Spreadsheets UI. Returns a 404 if no matching query result is found.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.export_query_result_to_spreadsheets_using_post_with_http_info(query_result_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str query_result_id: The unique identifier of the query result (required)
        :param ExportQueryResultDto dto: The representation of the export query result
        :return: BaseResponseOfstring
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['query_result_id', 'dto']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method export_query_result_to_spreadsheets_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'query_result_id' is set
        if self.api_client.client_side_validation and ('query_result_id' not in params or
                                                       params['query_result_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `query_result_id` when calling `export_query_result_to_spreadsheets_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'query_result_id' in params:
            path_params['queryResultId'] = params['query_result_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dto' in params:
            body_params = params['dto']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/queryresult/{queryResultId}/export', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BaseResponseOfstring',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dependencies_using_get(self, query_id, **kwargs):  # noqa: E501
        """Retrieve dependencies  # noqa: E501

        Returns an unordered collection of all tables the matching query uses as datasources, including any shared tables outside of this OAuth token's workspace. The endpoint verifies the user has read permissions on the query, but _not_ on the tables returned.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dependencies_using_get(query_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str query_id: The unique identifier of the query (required)
        :param int limit: The number of dependencies to return, from 1 to 1000; by default, 1000
        :param str cursor: A paging cursor; if included, `limit` is ignored
        :param int offset: The item to start with on the page, greater than or equal to 0; by default, 0
        :return: PagedResponseOfTableDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_dependencies_using_get_with_http_info(query_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_dependencies_using_get_with_http_info(query_id, **kwargs)  # noqa: E501
            return data

    def get_dependencies_using_get_with_http_info(self, query_id, **kwargs):  # noqa: E501
        """Retrieve dependencies  # noqa: E501

        Returns an unordered collection of all tables the matching query uses as datasources, including any shared tables outside of this OAuth token's workspace. The endpoint verifies the user has read permissions on the query, but _not_ on the tables returned.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dependencies_using_get_with_http_info(query_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str query_id: The unique identifier of the query (required)
        :param int limit: The number of dependencies to return, from 1 to 1000; by default, 1000
        :param str cursor: A paging cursor; if included, `limit` is ignored
        :param int offset: The item to start with on the page, greater than or equal to 0; by default, 0
        :return: PagedResponseOfTableDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['query_id', 'limit', 'cursor', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dependencies_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'query_id' is set
        if self.api_client.client_side_validation and ('query_id' not in params or
                                                       params['query_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `query_id` when calling `get_dependencies_using_get`")  # noqa: E501

        if self.api_client.client_side_validation and ('limit' in params and params['limit'] > 1000):  # noqa: E501
            raise ValueError("Invalid value for parameter `limit` when calling `get_dependencies_using_get`, must be a value less than or equal to `1000`")  # noqa: E501
        if self.api_client.client_side_validation and ('limit' in params and params['limit'] < 1):  # noqa: E501
            raise ValueError("Invalid value for parameter `limit` when calling `get_dependencies_using_get`, must be a value greater than or equal to `1`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'query_id' in params:
            path_params['queryId'] = params['query_id']  # noqa: E501

        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/query/{queryId}/dependencies', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagedResponseOfTableDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_query_column_data_using_post(self, query_text_dto, **kwargs):  # noqa: E501
        """Retrieve query column data  # noqa: E501

        Returns a QueryColumnDataDto representing the column data for the given query text. If the query isn't valid, returns a 400.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_query_column_data_using_post(query_text_dto, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param QueryTextDto query_text_dto: The query text to parse, up to 30000 characters; must not be null or empty (required)
        :return: BaseResponseOfQueryColumnDataDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_query_column_data_using_post_with_http_info(query_text_dto, **kwargs)  # noqa: E501
        else:
            (data) = self.get_query_column_data_using_post_with_http_info(query_text_dto, **kwargs)  # noqa: E501
            return data

    def get_query_column_data_using_post_with_http_info(self, query_text_dto, **kwargs):  # noqa: E501
        """Retrieve query column data  # noqa: E501

        Returns a QueryColumnDataDto representing the column data for the given query text. If the query isn't valid, returns a 400.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_query_column_data_using_post_with_http_info(query_text_dto, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param QueryTextDto query_text_dto: The query text to parse, up to 30000 characters; must not be null or empty (required)
        :return: BaseResponseOfQueryColumnDataDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['query_text_dto']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_query_column_data_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'query_text_dto' is set
        if self.api_client.client_side_validation and ('query_text_dto' not in params or
                                                       params['query_text_dto'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `query_text_dto` when calling `get_query_column_data_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'query_text_dto' in params:
            body_params = params['query_text_dto']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/query/data', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BaseResponseOfQueryColumnDataDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_query_result_using_get(self, query_result_id, **kwargs):  # noqa: E501
        """Retrieve a single query result  # noqa: E501

        Returns a single query result that matches the provided ID, or a 404 if no such query result is found.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_query_result_using_get(query_result_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str query_result_id: The unique identifier of the query result (required)
        :return: BaseResponseOfQueryResultDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_query_result_using_get_with_http_info(query_result_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_query_result_using_get_with_http_info(query_result_id, **kwargs)  # noqa: E501
            return data

    def get_query_result_using_get_with_http_info(self, query_result_id, **kwargs):  # noqa: E501
        """Retrieve a single query result  # noqa: E501

        Returns a single query result that matches the provided ID, or a 404 if no such query result is found.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_query_result_using_get_with_http_info(query_result_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str query_result_id: The unique identifier of the query result (required)
        :return: BaseResponseOfQueryResultDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['query_result_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_query_result_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'query_result_id' is set
        if self.api_client.client_side_validation and ('query_result_id' not in params or
                                                       params['query_result_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `query_result_id` when calling `get_query_result_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'query_result_id' in params:
            path_params['queryResultId'] = params['query_result_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/queryresult/{queryResultId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BaseResponseOfQueryResultDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_query_using_get(self, query_id, **kwargs):  # noqa: E501
        """Retrieve a single query  # noqa: E501

        Returns a query that matches the provided ID, or a 404 if no matching query is found.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_query_using_get(query_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str query_id: The unique identifier of the query (required)
        :return: BaseResponseOfQueryDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_query_using_get_with_http_info(query_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_query_using_get_with_http_info(query_id, **kwargs)  # noqa: E501
            return data

    def get_query_using_get_with_http_info(self, query_id, **kwargs):  # noqa: E501
        """Retrieve a single query  # noqa: E501

        Returns a query that matches the provided ID, or a 404 if no matching query is found.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_query_using_get_with_http_info(query_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str query_id: The unique identifier of the query (required)
        :return: BaseResponseOfQueryDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['query_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_query_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'query_id' is set
        if self.api_client.client_side_validation and ('query_id' not in params or
                                                       params['query_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `query_id` when calling `get_query_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'query_id' in params:
            path_params['queryId'] = params['query_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/query/{queryId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BaseResponseOfQueryDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_tables_dependent_on_query_using_get(self, query_id, **kwargs):  # noqa: E501
        """Retrieve a list of dependents  # noqa: E501

        Returns a list of all tables that use the query with provided ID as a datasource.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tables_dependent_on_query_using_get(query_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str query_id: The unique identifier of the query (required)
        :param int limit: The number of folders to return, from 1 to 1000; by default, 1000
        :param str cursor: A paging cursor; if included, `limit` is ignored
        :param int offset: The item to start with on the page, greater than or equal to 0; by default, 0
        :return: PagedResponseOfTableDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_tables_dependent_on_query_using_get_with_http_info(query_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_tables_dependent_on_query_using_get_with_http_info(query_id, **kwargs)  # noqa: E501
            return data

    def get_tables_dependent_on_query_using_get_with_http_info(self, query_id, **kwargs):  # noqa: E501
        """Retrieve a list of dependents  # noqa: E501

        Returns a list of all tables that use the query with provided ID as a datasource.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tables_dependent_on_query_using_get_with_http_info(query_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str query_id: The unique identifier of the query (required)
        :param int limit: The number of folders to return, from 1 to 1000; by default, 1000
        :param str cursor: A paging cursor; if included, `limit` is ignored
        :param int offset: The item to start with on the page, greater than or equal to 0; by default, 0
        :return: PagedResponseOfTableDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['query_id', 'limit', 'cursor', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tables_dependent_on_query_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'query_id' is set
        if self.api_client.client_side_validation and ('query_id' not in params or
                                                       params['query_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `query_id` when calling `get_tables_dependent_on_query_using_get`")  # noqa: E501

        if self.api_client.client_side_validation and ('limit' in params and params['limit'] > 1000):  # noqa: E501
            raise ValueError("Invalid value for parameter `limit` when calling `get_tables_dependent_on_query_using_get`, must be a value less than or equal to `1000`")  # noqa: E501
        if self.api_client.client_side_validation and ('limit' in params and params['limit'] < 1):  # noqa: E501
            raise ValueError("Invalid value for parameter `limit` when calling `get_tables_dependent_on_query_using_get`, must be a value greater than or equal to `1`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'query_id' in params:
            path_params['queryId'] = params['query_id']  # noqa: E501

        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/query/{queryId}/dependents', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagedResponseOfTableDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def is_query_valid_using_post(self, **kwargs):  # noqa: E501
        """Parses the query to determine if it is valid  # noqa: E501

        Returns the provided QueryDto  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.is_query_valid_using_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param QueryDto query_dto: The representation of the created query
        :return: BaseResponseOfQueryDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.is_query_valid_using_post_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.is_query_valid_using_post_with_http_info(**kwargs)  # noqa: E501
            return data

    def is_query_valid_using_post_with_http_info(self, **kwargs):  # noqa: E501
        """Parses the query to determine if it is valid  # noqa: E501

        Returns the provided QueryDto  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.is_query_valid_using_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param QueryDto query_dto: The representation of the created query
        :return: BaseResponseOfQueryDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['query_dto']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method is_query_valid_using_post" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'query_dto' in params:
            body_params = params['query_dto']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/query/validation', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BaseResponseOfQueryDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_queries_using_get(self, **kwargs):  # noqa: E501
        """Retrieve list of queries  # noqa: E501

        Returns a list of all non-temporary queries associated with the workspace. By default, these queries are ordered by their names, in ascending order.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_queries_using_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int limit: The number of queries to return, from 1 to 1000; by default, 1000
        :param str cursor: A paging cursor; if included, `limit` is ignored
        :param int offset: The item to start with on the page, greater than or equal to 0; by default, 0
        :return: PagedResponseOfQueryDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_queries_using_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_queries_using_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_queries_using_get_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve list of queries  # noqa: E501

        Returns a list of all non-temporary queries associated with the workspace. By default, these queries are ordered by their names, in ascending order.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_queries_using_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int limit: The number of queries to return, from 1 to 1000; by default, 1000
        :param str cursor: A paging cursor; if included, `limit` is ignored
        :param int offset: The item to start with on the page, greater than or equal to 0; by default, 0
        :return: PagedResponseOfQueryDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['limit', 'cursor', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_queries_using_get" % key
                )
            params[key] = val
        del params['kwargs']

        if self.api_client.client_side_validation and ('limit' in params and params['limit'] > 1000):  # noqa: E501
            raise ValueError("Invalid value for parameter `limit` when calling `list_queries_using_get`, must be a value less than or equal to `1000`")  # noqa: E501
        if self.api_client.client_side_validation and ('limit' in params and params['limit'] < 1):  # noqa: E501
            raise ValueError("Invalid value for parameter `limit` when calling `list_queries_using_get`, must be a value greater than or equal to `1`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/query', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagedResponseOfQueryDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_query_results_using_get(self, **kwargs):  # noqa: E501
        """Retrieve a list of query results  # noqa: E501

        Returns a paged list of query results that match the provided query ID, or an empty list if no matching query is found.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_query_results_using_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str query_id: The unique identifier of the query
        :param str cursor: A paging cursor; if included, `limit` is ignored
        :param int limit: The number of query results to return, from 1 to 1000; by default, 1000
        :param int offset: The item to start with on the page, greater than or equal to 0; by default, 0
        :return: PagedResponseOfQueryResultDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_query_results_using_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_query_results_using_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_query_results_using_get_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve a list of query results  # noqa: E501

        Returns a paged list of query results that match the provided query ID, or an empty list if no matching query is found.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_query_results_using_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str query_id: The unique identifier of the query
        :param str cursor: A paging cursor; if included, `limit` is ignored
        :param int limit: The number of query results to return, from 1 to 1000; by default, 1000
        :param int offset: The item to start with on the page, greater than or equal to 0; by default, 0
        :return: PagedResponseOfQueryResultDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['query_id', 'cursor', 'limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_query_results_using_get" % key
                )
            params[key] = val
        del params['kwargs']

        if self.api_client.client_side_validation and ('limit' in params and params['limit'] > 1000):  # noqa: E501
            raise ValueError("Invalid value for parameter `limit` when calling `list_query_results_using_get`, must be a value less than or equal to `1000`")  # noqa: E501
        if self.api_client.client_side_validation and ('limit' in params and params['limit'] < 1):  # noqa: E501
            raise ValueError("Invalid value for parameter `limit` when calling `list_query_results_using_get`, must be a value greater than or equal to `1`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'query_id' in params:
            query_params.append(('queryId', params['query_id']))  # noqa: E501
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/queryresult', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagedResponseOfQueryResultDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def preview_query_using_post(self, table_id, **kwargs):  # noqa: E501
        """Preview a query  # noqa: E501

        Creates a limited scope query object, but does _not_ execute it. The query selects all values against the provided table, up to 10 rows. This endpoint may allow unpermissioned users to preview table data; full permissions to datasources are _not_ validated.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.preview_query_using_post(table_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str table_id: The identifier of the table to query (required)
        :param int limit: The number of rows to return
        :param str file_name: The name of the file to create
        :return: BaseResponseOfQueryDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.preview_query_using_post_with_http_info(table_id, **kwargs)  # noqa: E501
        else:
            (data) = self.preview_query_using_post_with_http_info(table_id, **kwargs)  # noqa: E501
            return data

    def preview_query_using_post_with_http_info(self, table_id, **kwargs):  # noqa: E501
        """Preview a query  # noqa: E501

        Creates a limited scope query object, but does _not_ execute it. The query selects all values against the provided table, up to 10 rows. This endpoint may allow unpermissioned users to preview table data; full permissions to datasources are _not_ validated.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.preview_query_using_post_with_http_info(table_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str table_id: The identifier of the table to query (required)
        :param int limit: The number of rows to return
        :param str file_name: The name of the file to create
        :return: BaseResponseOfQueryDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['table_id', 'limit', 'file_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method preview_query_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'table_id' is set
        if self.api_client.client_side_validation and ('table_id' not in params or
                                                       params['table_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `table_id` when calling `preview_query_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'table_id' in params:
            path_params['tableId'] = params['table_id']  # noqa: E501

        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'file_name' in params:
            query_params.append(('fileName', params['file_name']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/query/preview/{tableId}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BaseResponseOfQueryDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def run_query_using_post(self, **kwargs):  # noqa: E501
        """Execute a query  # noqa: E501

        Runs a query and immediately returns a query result entity, which has an ID that can be used to poll the status from the GET /queryresult method. A status of COMPLETED or ERROR indicates the query has completed.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.run_query_using_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param QueryResultDto query_result_dto: The representation of the created query
        :return: BaseResponseOfQueryResultDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.run_query_using_post_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.run_query_using_post_with_http_info(**kwargs)  # noqa: E501
            return data

    def run_query_using_post_with_http_info(self, **kwargs):  # noqa: E501
        """Execute a query  # noqa: E501

        Runs a query and immediately returns a query result entity, which has an ID that can be used to poll the status from the GET /queryresult method. A status of COMPLETED or ERROR indicates the query has completed.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.run_query_using_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param QueryResultDto query_result_dto: The representation of the created query
        :return: BaseResponseOfQueryResultDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['query_result_dto']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method run_query_using_post" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'query_result_dto' in params:
            body_params = params['query_result_dto']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/queryresult', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BaseResponseOfQueryResultDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_query_using_put(self, query_id, **kwargs):  # noqa: E501
        """Update a single query  # noqa: E501

        Updates the query that matches the provided ID with the details provided in the body.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_query_using_put(query_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str query_id: The unique identifier of the query (required)
        :param QueryDto query_dto: The representation of the query to update
        :return: BaseResponseOfQueryDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_query_using_put_with_http_info(query_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_query_using_put_with_http_info(query_id, **kwargs)  # noqa: E501
            return data

    def update_query_using_put_with_http_info(self, query_id, **kwargs):  # noqa: E501
        """Update a single query  # noqa: E501

        Updates the query that matches the provided ID with the details provided in the body.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_query_using_put_with_http_info(query_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str query_id: The unique identifier of the query (required)
        :param QueryDto query_dto: The representation of the query to update
        :return: BaseResponseOfQueryDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['query_id', 'query_dto']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_query_using_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'query_id' is set
        if self.api_client.client_side_validation and ('query_id' not in params or
                                                       params['query_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `query_id` when calling `update_query_using_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'query_id' in params:
            path_params['queryId'] = params['query_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'query_dto' in params:
            body_params = params['query_dto']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/query/{queryId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BaseResponseOfQueryDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
