# coding: utf-8

"""
    Cerebral API

    The Wdata Preparation API allow users to import data sets from their source system, tag, organize, manipulate, share, export, and query against the data  # noqa: E501

    OpenAPI spec version: 1.0
    Contact: scoutteam@workiva.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class FolderManagementApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def create_folder_using_post(self, **kwargs):  # noqa: E501
        """Create a new folder  # noqa: E501

        Creates a folder using the provided information and returns the folder meta.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_folder_using_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FolderDto folder_dto: The representation of the folder to create
        :return: BaseResponseOfFolderDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_folder_using_post_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_folder_using_post_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_folder_using_post_with_http_info(self, **kwargs):  # noqa: E501
        """Create a new folder  # noqa: E501

        Creates a folder using the provided information and returns the folder meta.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_folder_using_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FolderDto folder_dto: The representation of the folder to create
        :return: BaseResponseOfFolderDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['folder_dto']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_folder_using_post" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'folder_dto' in params:
            body_params = params['folder_dto']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/folder', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BaseResponseOfFolderDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_folder_using_delete(self, folder_id, **kwargs):  # noqa: E501
        """Delete a single folder  # noqa: E501

        Deletes the folder with the provided ID.  If the folder is not found, this is a no-op. <b>All files and sub-folders are also recursively deleted.</b>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_folder_using_delete(folder_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str folder_id: The unique identifier of the folder (required)
        :return: BaseResponseOfstring
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_folder_using_delete_with_http_info(folder_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_folder_using_delete_with_http_info(folder_id, **kwargs)  # noqa: E501
            return data

    def delete_folder_using_delete_with_http_info(self, folder_id, **kwargs):  # noqa: E501
        """Delete a single folder  # noqa: E501

        Deletes the folder with the provided ID.  If the folder is not found, this is a no-op. <b>All files and sub-folders are also recursively deleted.</b>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_folder_using_delete_with_http_info(folder_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str folder_id: The unique identifier of the folder (required)
        :return: BaseResponseOfstring
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['folder_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_folder_using_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'folder_id' is set
        if self.api_client.client_side_validation and ('folder_id' not in params or
                                                       params['folder_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `folder_id` when calling `delete_folder_using_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'folder_id' in params:
            path_params['folderId'] = params['folder_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/folder/{folderId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BaseResponseOfstring',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_folder_using_get(self, folder_id, **kwargs):  # noqa: E501
        """Retrieve a single folder  # noqa: E501

        Returns a folder with the provided ID, or a 404 if no matching folder is found.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_folder_using_get(folder_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str folder_id: The unique identifier of the folder (required)
        :return: BaseResponseOfFolderDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_folder_using_get_with_http_info(folder_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_folder_using_get_with_http_info(folder_id, **kwargs)  # noqa: E501
            return data

    def get_folder_using_get_with_http_info(self, folder_id, **kwargs):  # noqa: E501
        """Retrieve a single folder  # noqa: E501

        Returns a folder with the provided ID, or a 404 if no matching folder is found.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_folder_using_get_with_http_info(folder_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str folder_id: The unique identifier of the folder (required)
        :return: BaseResponseOfFolderDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['folder_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_folder_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'folder_id' is set
        if self.api_client.client_side_validation and ('folder_id' not in params or
                                                       params['folder_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `folder_id` when calling `get_folder_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'folder_id' in params:
            path_params['folderId'] = params['folder_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/folder/{folderId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BaseResponseOfFolderDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_children_using_get(self, folder_id, **kwargs):  # noqa: E501
        """Retrieve list of folder contents  # noqa: E501

        Returns a paged list of all children whose parent ID matches the provided folder ID.  If the folder ID in the path is the literal 'null' value, returns a list of all entities with no parent.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_children_using_get(folder_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str folder_id: The unique identifier of the folder (required)
        :param int limit: The number of folders to return, from 1 to 1000; by default, 1000
        :param str cursor: A paging cursor; if included, `limit` is ignored
        :param int offset: The item to start with on the page, greater than or equal to 0; by default, 0
        :return: PagedResponseOfFolderableDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_children_using_get_with_http_info(folder_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_children_using_get_with_http_info(folder_id, **kwargs)  # noqa: E501
            return data

    def list_children_using_get_with_http_info(self, folder_id, **kwargs):  # noqa: E501
        """Retrieve list of folder contents  # noqa: E501

        Returns a paged list of all children whose parent ID matches the provided folder ID.  If the folder ID in the path is the literal 'null' value, returns a list of all entities with no parent.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_children_using_get_with_http_info(folder_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str folder_id: The unique identifier of the folder (required)
        :param int limit: The number of folders to return, from 1 to 1000; by default, 1000
        :param str cursor: A paging cursor; if included, `limit` is ignored
        :param int offset: The item to start with on the page, greater than or equal to 0; by default, 0
        :return: PagedResponseOfFolderableDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['folder_id', 'limit', 'cursor', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_children_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'folder_id' is set
        if self.api_client.client_side_validation and ('folder_id' not in params or
                                                       params['folder_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `folder_id` when calling `list_children_using_get`")  # noqa: E501

        if self.api_client.client_side_validation and ('limit' in params and params['limit'] > 1000):  # noqa: E501
            raise ValueError("Invalid value for parameter `limit` when calling `list_children_using_get`, must be a value less than or equal to `1000`")  # noqa: E501
        if self.api_client.client_side_validation and ('limit' in params and params['limit'] < 1):  # noqa: E501
            raise ValueError("Invalid value for parameter `limit` when calling `list_children_using_get`, must be a value greater than or equal to `1`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'folder_id' in params:
            path_params['folderId'] = params['folder_id']  # noqa: E501

        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/folder/{folderId}/children', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagedResponseOfFolderableDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_folders_using_get(self, **kwargs):  # noqa: E501
        """Retrieve a list of folders  # noqa: E501

        Returns a paged list of all folders associated with the workspace.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_folders_using_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int limit: The number of folders to return, from 1 to 1000; by default, 1000
        :param str cursor: A paging cursor; if included, `limit` is ignored
        :param int offset: The item to start with on the page, greater than or equal to 0; by default, 0
        :return: PagedResponseOfFolderDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_folders_using_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_folders_using_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_folders_using_get_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve a list of folders  # noqa: E501

        Returns a paged list of all folders associated with the workspace.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_folders_using_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int limit: The number of folders to return, from 1 to 1000; by default, 1000
        :param str cursor: A paging cursor; if included, `limit` is ignored
        :param int offset: The item to start with on the page, greater than or equal to 0; by default, 0
        :return: PagedResponseOfFolderDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['limit', 'cursor', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_folders_using_get" % key
                )
            params[key] = val
        del params['kwargs']

        if self.api_client.client_side_validation and ('limit' in params and params['limit'] > 1000):  # noqa: E501
            raise ValueError("Invalid value for parameter `limit` when calling `list_folders_using_get`, must be a value less than or equal to `1000`")  # noqa: E501
        if self.api_client.client_side_validation and ('limit' in params and params['limit'] < 1):  # noqa: E501
            raise ValueError("Invalid value for parameter `limit` when calling `list_folders_using_get`, must be a value greater than or equal to `1`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/folder', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagedResponseOfFolderDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_using_get(self, **kwargs):  # noqa: E501
        """Search  # noqa: E501

        Returns a list of all entities that match the provided criteria. Both name and description are fuzzy matches; they match _any_ entity that contains the provided string. The type is used to filter results based on the provided type of entity.  The consumer must have READ access on all returned entities.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_using_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: The name to use when fuzzy-matching entities
        :param str description: The description to use when fuzzy-matching entities
        :param list[int] type: To limit the scope, the type of entity to return in the results
        :param int limit: The number of folders to return, from 1 to 1000; by default, 1000
        :param str cursor: A paging cursor; if included, `limit` is ignored
        :param int offset: The item to start with on the page, greater than or equal to 0; by default, 0
        :return: PagedResponseOfFolderableDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.search_using_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_using_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_using_get_with_http_info(self, **kwargs):  # noqa: E501
        """Search  # noqa: E501

        Returns a list of all entities that match the provided criteria. Both name and description are fuzzy matches; they match _any_ entity that contains the provided string. The type is used to filter results based on the provided type of entity.  The consumer must have READ access on all returned entities.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_using_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: The name to use when fuzzy-matching entities
        :param str description: The description to use when fuzzy-matching entities
        :param list[int] type: To limit the scope, the type of entity to return in the results
        :param int limit: The number of folders to return, from 1 to 1000; by default, 1000
        :param str cursor: A paging cursor; if included, `limit` is ignored
        :param int offset: The item to start with on the page, greater than or equal to 0; by default, 0
        :return: PagedResponseOfFolderableDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'description', 'type', 'limit', 'cursor', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_using_get" % key
                )
            params[key] = val
        del params['kwargs']

        if self.api_client.client_side_validation and ('limit' in params and params['limit'] > 1000):  # noqa: E501
            raise ValueError("Invalid value for parameter `limit` when calling `search_using_get`, must be a value less than or equal to `1000`")  # noqa: E501
        if self.api_client.client_side_validation and ('limit' in params and params['limit'] < 1):  # noqa: E501
            raise ValueError("Invalid value for parameter `limit` when calling `search_using_get`, must be a value greater than or equal to `1`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'description' in params:
            query_params.append(('description', params['description']))  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
            collection_formats['type'] = 'multi'  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/entity', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagedResponseOfFolderableDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_children_using_post(self, folder_id, **kwargs):  # noqa: E501
        """Move content into a folder  # noqa: E501

        Sets the children of a folder using the entities' types and IDs provided in the body. If the entities previously resided under a folder, including the root, they move to the folder with the provided ID. If the provided ID is 'null', the entities move to the root folder.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_children_using_post(folder_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str folder_id: The unique identifier of the folder (required)
        :param list[FolderableDto] children: The representation of the entities to drop into the folder
        :return: BaseResponseOfCollectionOfFolderableDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_children_using_post_with_http_info(folder_id, **kwargs)  # noqa: E501
        else:
            (data) = self.set_children_using_post_with_http_info(folder_id, **kwargs)  # noqa: E501
            return data

    def set_children_using_post_with_http_info(self, folder_id, **kwargs):  # noqa: E501
        """Move content into a folder  # noqa: E501

        Sets the children of a folder using the entities' types and IDs provided in the body. If the entities previously resided under a folder, including the root, they move to the folder with the provided ID. If the provided ID is 'null', the entities move to the root folder.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_children_using_post_with_http_info(folder_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str folder_id: The unique identifier of the folder (required)
        :param list[FolderableDto] children: The representation of the entities to drop into the folder
        :return: BaseResponseOfCollectionOfFolderableDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['folder_id', 'children']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_children_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'folder_id' is set
        if self.api_client.client_side_validation and ('folder_id' not in params or
                                                       params['folder_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `folder_id` when calling `set_children_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'folder_id' in params:
            path_params['folderId'] = params['folder_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'children' in params:
            body_params = params['children']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/folder/{folderId}/children', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BaseResponseOfCollectionOfFolderableDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_folder_using_put(self, folder_id, **kwargs):  # noqa: E501
        """Update a single folder  # noqa: E501

        Updates the folder that matches the provided ID with the details provided in the body.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_folder_using_put(folder_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str folder_id: The unique identifier of the folder (required)
        :param FolderDto folder_dto: The representation of the folder to update
        :return: BaseResponseOfFolderDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_folder_using_put_with_http_info(folder_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_folder_using_put_with_http_info(folder_id, **kwargs)  # noqa: E501
            return data

    def update_folder_using_put_with_http_info(self, folder_id, **kwargs):  # noqa: E501
        """Update a single folder  # noqa: E501

        Updates the folder that matches the provided ID with the details provided in the body.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_folder_using_put_with_http_info(folder_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str folder_id: The unique identifier of the folder (required)
        :param FolderDto folder_dto: The representation of the folder to update
        :return: BaseResponseOfFolderDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['folder_id', 'folder_dto']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_folder_using_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'folder_id' is set
        if self.api_client.client_side_validation and ('folder_id' not in params or
                                                       params['folder_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `folder_id` when calling `update_folder_using_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'folder_id' in params:
            path_params['folderId'] = params['folder_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'folder_dto' in params:
            body_params = params['folder_dto']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/folder/{folderId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BaseResponseOfFolderDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
