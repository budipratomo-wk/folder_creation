# coding: utf-8

"""
    Cerebral API

    The Wdata Preparation API allow users to import data sets from their source system, tag, organize, manipulate, share, export, and query against the data  # noqa: E501

    OpenAPI spec version: 1.0
    Contact: scoutteam@workiva.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class FileManagementApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def delete_file_using_delete(self, file_id, **kwargs):  # noqa: E501
        """Delete a single file  # noqa: E501

        Unstages the file with the provided ID. The file must have a STAGED status; if the file isn't STAGED, returns a 409 status. If the file isn't found, this is a no-op.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_file_using_delete(file_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file_id: The unique identifier of the file (required)
        :return: BaseResponseOfstring
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_file_using_delete_with_http_info(file_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_file_using_delete_with_http_info(file_id, **kwargs)  # noqa: E501
            return data

    def delete_file_using_delete_with_http_info(self, file_id, **kwargs):  # noqa: E501
        """Delete a single file  # noqa: E501

        Unstages the file with the provided ID. The file must have a STAGED status; if the file isn't STAGED, returns a 409 status. If the file isn't found, this is a no-op.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_file_using_delete_with_http_info(file_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file_id: The unique identifier of the file (required)
        :return: BaseResponseOfstring
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_file_using_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file_id' is set
        if self.api_client.client_side_validation and ('file_id' not in params or
                                                       params['file_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `file_id` when calling `delete_file_using_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'file_id' in params:
            path_params['fileId'] = params['file_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/file/{fileId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BaseResponseOfstring',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def download_file_using_get(self, file_id, **kwargs):  # noqa: E501
        """Download a single file  # noqa: E501

        Returns a file with the provided ID, which points to a file meta ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.download_file_using_get(file_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file_id: The unique identifier of the file (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.download_file_using_get_with_http_info(file_id, **kwargs)  # noqa: E501
        else:
            (data) = self.download_file_using_get_with_http_info(file_id, **kwargs)  # noqa: E501
            return data

    def download_file_using_get_with_http_info(self, file_id, **kwargs):  # noqa: E501
        """Download a single file  # noqa: E501

        Returns a file with the provided ID, which points to a file meta ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.download_file_using_get_with_http_info(file_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file_id: The unique identifier of the file (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method download_file_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file_id' is set
        if self.api_client.client_side_validation and ('file_id' not in params or
                                                       params['file_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `file_id` when calling `download_file_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'file_id' in params:
            path_params['fileId'] = params['file_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/file/{fileId}/download', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def export_file_to_spreadsheets_using_post(self, file_id, **kwargs):  # noqa: E501
        """Export a file to spreadsheets  # noqa: E501

        Exports the file ID identified in the path to the spreadsheet identified by the provided URL. If the URL string is empty, creates and returns a new spreadsheet and its sheet IDs.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.export_file_to_spreadsheets_using_post(file_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file_id: The unique identifier of the file (required)
        :param ExportFileDto export_file_dto: The representation of the file to export
        :return: BaseResponseOfSpreadsheetInfoDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.export_file_to_spreadsheets_using_post_with_http_info(file_id, **kwargs)  # noqa: E501
        else:
            (data) = self.export_file_to_spreadsheets_using_post_with_http_info(file_id, **kwargs)  # noqa: E501
            return data

    def export_file_to_spreadsheets_using_post_with_http_info(self, file_id, **kwargs):  # noqa: E501
        """Export a file to spreadsheets  # noqa: E501

        Exports the file ID identified in the path to the spreadsheet identified by the provided URL. If the URL string is empty, creates and returns a new spreadsheet and its sheet IDs.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.export_file_to_spreadsheets_using_post_with_http_info(file_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file_id: The unique identifier of the file (required)
        :param ExportFileDto export_file_dto: The representation of the file to export
        :return: BaseResponseOfSpreadsheetInfoDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file_id', 'export_file_dto']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method export_file_to_spreadsheets_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file_id' is set
        if self.api_client.client_side_validation and ('file_id' not in params or
                                                       params['file_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `file_id` when calling `export_file_to_spreadsheets_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'file_id' in params:
            path_params['fileId'] = params['file_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'export_file_dto' in params:
            body_params = params['export_file_dto']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/file/{fileId}/export', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BaseResponseOfSpreadsheetInfoDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_errors_using_get(self, file_id, **kwargs):  # noqa: E501
        """Retrieve errors  # noqa: E501

        Returns a paged list of operation errors during the upload, import, or tagging processes for the provided file ID, if they exist. This list is immutable and may be empty if no errors have occurred. If errors exist we recommend fixing them and reimporting your file  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_errors_using_get(file_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file_id: The unique identifier of the file (required)
        :param int limit: The number of errors to return, from 1 to 50; by default, 50
        :param str cursor: A paging cursor; if included, `limit` is ignored
        :param int offset: The item to start with on the page, greater than or equal to 0; by default, 0
        :return: PagedResponseOfImportErrorDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_errors_using_get_with_http_info(file_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_errors_using_get_with_http_info(file_id, **kwargs)  # noqa: E501
            return data

    def get_errors_using_get_with_http_info(self, file_id, **kwargs):  # noqa: E501
        """Retrieve errors  # noqa: E501

        Returns a paged list of operation errors during the upload, import, or tagging processes for the provided file ID, if they exist. This list is immutable and may be empty if no errors have occurred. If errors exist we recommend fixing them and reimporting your file  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_errors_using_get_with_http_info(file_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file_id: The unique identifier of the file (required)
        :param int limit: The number of errors to return, from 1 to 50; by default, 50
        :param str cursor: A paging cursor; if included, `limit` is ignored
        :param int offset: The item to start with on the page, greater than or equal to 0; by default, 0
        :return: PagedResponseOfImportErrorDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file_id', 'limit', 'cursor', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_errors_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file_id' is set
        if self.api_client.client_side_validation and ('file_id' not in params or
                                                       params['file_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `file_id` when calling `get_errors_using_get`")  # noqa: E501

        if self.api_client.client_side_validation and ('limit' in params and params['limit'] > 50):  # noqa: E501
            raise ValueError("Invalid value for parameter `limit` when calling `get_errors_using_get`, must be a value less than or equal to `50`")  # noqa: E501
        if self.api_client.client_side_validation and ('limit' in params and params['limit'] < 1):  # noqa: E501
            raise ValueError("Invalid value for parameter `limit` when calling `get_errors_using_get`, must be a value greater than or equal to `1`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'file_id' in params:
            path_params['fileId'] = params['file_id']  # noqa: E501

        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/file/{fileId}/error', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagedResponseOfImportErrorDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_file_using_get(self, file_id, **kwargs):  # noqa: E501
        """Retrieve a single file  # noqa: E501

        Returns the file meta that matches the provided ID, or a 404 if an associated file can't be found.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_file_using_get(file_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file_id: The unique identifier of the file (required)
        :return: BaseResponseOfFileMetaDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_file_using_get_with_http_info(file_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_file_using_get_with_http_info(file_id, **kwargs)  # noqa: E501
            return data

    def get_file_using_get_with_http_info(self, file_id, **kwargs):  # noqa: E501
        """Retrieve a single file  # noqa: E501

        Returns the file meta that matches the provided ID, or a 404 if an associated file can't be found.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_file_using_get_with_http_info(file_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file_id: The unique identifier of the file (required)
        :return: BaseResponseOfFileMetaDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_file_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file_id' is set
        if self.api_client.client_side_validation and ('file_id' not in params or
                                                       params['file_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `file_id` when calling `get_file_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'file_id' in params:
            path_params['fileId'] = params['file_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/file/{fileId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BaseResponseOfFileMetaDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_files_using_get(self, table_id, **kwargs):  # noqa: E501
        """Retrieve a list of files  # noqa: E501

        Returns a paged list of all files associated with the provided table ID, as well as metadata associated with each file.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_files_using_get(table_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str table_id: The unique table identifier associated with this file (required)
        :param int limit: The number of files to return, from 1 to 1000; by default, 1000
        :param str cursor: A paging cursor; if included, `limit` is ignored
        :param int offset: The item to start with on the page, greater than or equal to 0; by default, 0
        :param str sort_order: The sort order for the files being returned
        :param str sort_by: The column to use the sort order on
        :param str search_text: The text to filter the results upon; matching the file name
        :return: PagedResponseOfFileMetaDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_files_using_get_with_http_info(table_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_files_using_get_with_http_info(table_id, **kwargs)  # noqa: E501
            return data

    def get_files_using_get_with_http_info(self, table_id, **kwargs):  # noqa: E501
        """Retrieve a list of files  # noqa: E501

        Returns a paged list of all files associated with the provided table ID, as well as metadata associated with each file.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_files_using_get_with_http_info(table_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str table_id: The unique table identifier associated with this file (required)
        :param int limit: The number of files to return, from 1 to 1000; by default, 1000
        :param str cursor: A paging cursor; if included, `limit` is ignored
        :param int offset: The item to start with on the page, greater than or equal to 0; by default, 0
        :param str sort_order: The sort order for the files being returned
        :param str sort_by: The column to use the sort order on
        :param str search_text: The text to filter the results upon; matching the file name
        :return: PagedResponseOfFileMetaDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['table_id', 'limit', 'cursor', 'offset', 'sort_order', 'sort_by', 'search_text']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_files_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'table_id' is set
        if self.api_client.client_side_validation and ('table_id' not in params or
                                                       params['table_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `table_id` when calling `get_files_using_get`")  # noqa: E501

        if self.api_client.client_side_validation and ('limit' in params and params['limit'] > 1000):  # noqa: E501
            raise ValueError("Invalid value for parameter `limit` when calling `get_files_using_get`, must be a value less than or equal to `1000`")  # noqa: E501
        if self.api_client.client_side_validation and ('limit' in params and params['limit'] < 1):  # noqa: E501
            raise ValueError("Invalid value for parameter `limit` when calling `get_files_using_get`, must be a value greater than or equal to `1`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'table_id' in params:
            query_params.append(('tableId', params['table_id']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'sort_order' in params:
            query_params.append(('sortOrder', params['sort_order']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sortBy', params['sort_by']))  # noqa: E501
        if 'search_text' in params:
            query_params.append(('searchText', params['search_text']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/file', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagedResponseOfFileMetaDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def upload_file_using_post(self, table_id, **kwargs):  # noqa: E501
        """Upload a single file  # noqa: E501

        Accepts CSV, TSV, or JSON files, or a ZIP file that contains a single CSV, TSV, or JSON file. If a ZIP, it must contain a CSV, TSV, or JSON file, and the name of the CSV, TSV, or JSON file is also used with the imported file. Downloading this file again downloads the source. <br><br> You can also upload a URL to the file, such as an S3-signed URL to a file in an S3 bucket. The endpoint then makes a request to get the file using a simple unauthenticated `GET` request. <br><br> Note that all files uploaded must have a .csv, .tsv, or .json extension. JSON files are expected to have a single JSON record per line; a JSON file is a series of JSON objects delimited by a newline character.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upload_file_using_post(table_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str table_id: The unique table identifier associated with this file (required)
        :param file file: The physical file to upload
        :param str name: No longer in use, here to ensure backwards compatibility
        :param str url: No longer in use, here to ensure backwards compatibility
        :param str source: The data source to associate with the file, no more than 255 characters. This field is not in use; it only keeps track of the source
        :param str delimiter: The character to use as a delimiter within the file to separate one field from another.  The default is comma
        :return: BaseResponseOfFileMetaDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.upload_file_using_post_with_http_info(table_id, **kwargs)  # noqa: E501
        else:
            (data) = self.upload_file_using_post_with_http_info(table_id, **kwargs)  # noqa: E501
            return data

    def upload_file_using_post_with_http_info(self, table_id, **kwargs):  # noqa: E501
        """Upload a single file  # noqa: E501

        Accepts CSV, TSV, or JSON files, or a ZIP file that contains a single CSV, TSV, or JSON file. If a ZIP, it must contain a CSV, TSV, or JSON file, and the name of the CSV, TSV, or JSON file is also used with the imported file. Downloading this file again downloads the source. <br><br> You can also upload a URL to the file, such as an S3-signed URL to a file in an S3 bucket. The endpoint then makes a request to get the file using a simple unauthenticated `GET` request. <br><br> Note that all files uploaded must have a .csv, .tsv, or .json extension. JSON files are expected to have a single JSON record per line; a JSON file is a series of JSON objects delimited by a newline character.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upload_file_using_post_with_http_info(table_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str table_id: The unique table identifier associated with this file (required)
        :param file file: The physical file to upload
        :param str name: No longer in use, here to ensure backwards compatibility
        :param str url: No longer in use, here to ensure backwards compatibility
        :param str source: The data source to associate with the file, no more than 255 characters. This field is not in use; it only keeps track of the source
        :param str delimiter: The character to use as a delimiter within the file to separate one field from another.  The default is comma
        :return: BaseResponseOfFileMetaDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['table_id', 'file', 'name', 'url', 'source', 'delimiter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upload_file_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'table_id' is set
        if self.api_client.client_side_validation and ('table_id' not in params or
                                                       params['table_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `table_id` when calling `upload_file_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']  # noqa: E501
        if 'table_id' in params:
            form_params.append(('tableId', params['table_id']))  # noqa: E501
        if 'name' in params:
            form_params.append(('name', params['name']))  # noqa: E501
        if 'url' in params:
            form_params.append(('url', params['url']))  # noqa: E501
        if 'source' in params:
            form_params.append(('source', params['source']))  # noqa: E501
        if 'delimiter' in params:
            form_params.append(('delimiter', params['delimiter']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/file', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BaseResponseOfFileMetaDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def validate_filename_using_get(self, table_id, filename, **kwargs):  # noqa: E501
        """Validate whether a file with the filename can be uploaded to the table  # noqa: E501

        If the filename is valid, this returns 200. If the table already has a file with the same name, this returns 409. If the user isn't allowed to read the table, or if the table isn't found, this returns 404.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.validate_filename_using_get(table_id, filename, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str table_id: The ID of the table to upload the file to (required)
        :param str filename: The name of the file to upload (required)
        :return: BaseResponseOfstring
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.validate_filename_using_get_with_http_info(table_id, filename, **kwargs)  # noqa: E501
        else:
            (data) = self.validate_filename_using_get_with_http_info(table_id, filename, **kwargs)  # noqa: E501
            return data

    def validate_filename_using_get_with_http_info(self, table_id, filename, **kwargs):  # noqa: E501
        """Validate whether a file with the filename can be uploaded to the table  # noqa: E501

        If the filename is valid, this returns 200. If the table already has a file with the same name, this returns 409. If the user isn't allowed to read the table, or if the table isn't found, this returns 404.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.validate_filename_using_get_with_http_info(table_id, filename, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str table_id: The ID of the table to upload the file to (required)
        :param str filename: The name of the file to upload (required)
        :return: BaseResponseOfstring
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['table_id', 'filename']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method validate_filename_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'table_id' is set
        if self.api_client.client_side_validation and ('table_id' not in params or
                                                       params['table_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `table_id` when calling `validate_filename_using_get`")  # noqa: E501
        # verify the required parameter 'filename' is set
        if self.api_client.client_side_validation and ('filename' not in params or
                                                       params['filename'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `filename` when calling `validate_filename_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'table_id' in params:
            query_params.append(('tableId', params['table_id']))  # noqa: E501
        if 'filename' in params:
            query_params.append(('filename', params['filename']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/file/validateName', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BaseResponseOfstring',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
